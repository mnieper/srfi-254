<!DOCTYPE html>
<html lang="en">
  <!--
      SPDX-FileCopyrightText: Marc Nieper-Wißkirchen
      SPDX-License-Identifier: MIT
    -->
  <head>
    <meta charset="utf-8">
    <title>SRFI 254: Ephemerons and Guardians</title>
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png">
    <link rel="stylesheet" href="https://srfi.schemers.org/srfi.css" type="text/css">
    <meta name="viewport" content="width=device-width, initial-scale=1"></head>
  <body>
    <h1><a href="https://srfi.schemers.org/"><img class="srfi-logo" src="https://srfi.schemers.org/srfi-logo.svg" alt="SRFI surfboard logo" /></a>254: Ephemerons and Guardians</h1>

    <p>by Marc Nieper-Wißkirchen</p>

    <h2 id="status">Status</h2>

    <p>This SRFI is currently in <em>draft</em> status.  Here is <a href="https://srfi.schemers.org/srfi-process.html">an explanation</a> of each status that a SRFI can hold.  To provide input on this SRFI, please send email to <code><a href="mailto:srfi+minus+254+at+srfi+dotschemers+dot+org">srfi-254@<span class="antispam">nospam</span>srfi.schemers.org</a></code>.  To subscribe to the list, follow <a href="https://srfi.schemers.org/srfi-list-subscribe.html">these instructions</a>.  You can access previous messages via the mailing list <a href="https://srfi-email.schemers.org/srfi-254/">archive</a>.</p>
    <ul>
      <li>Received: 2024-09-11
        <p>This SRFI was forked from SRFI 246 on that date.</p></li>
      <li>Draft #1 published: 2024-09-11</li>
      <li>60-day deadline: 2024-11-12</li>
    </ul>

    <h2 id="abstract">Abstract</h2>

    <p>Guardians allow programs to protect objects from deallocation by the garbage collector and to determine which objects would otherwise have been deallocated. When the object has associated non-memory resources, a program can register it with a guardian. The GC will mark inaccessible objects but will not collect them; at the program's convenience, inaccessible objects are removed from the guardian and their non-memory resources are disposed of.

      Guardians allow objects to be saved from deallocation indefinitely so that they can be reused or so that clean-up or other actions can be performed using the data stored within the objects. Guardians avoid the problems associated with classical finalizers detailed in the Rationale section.</p>

    <h2 id="issues">Issues</h2>

    <ul>
      <li>Include examples.</li>
      <li>Write tests.</li>
    </ul>

    <h2 id="rationale">Rationale</h2>

    <p>The difficulties with classical finalizers are:</p>

    <ul><li>When run directly by the garbage collector, they must be executed within a critical section, because the collector may interrupt the rest of the program at arbitrary points.</li>

      <li>When cyclic and shared structures must be finalized, it may be essential to control the order in which finalization is done.</li>

      <li>They do not always allow the full range of language features to be employed. For example, allocation may not be possible from within the garbage collector, as the collector may not be re-entrant. If an error is signaled while the collector is running, it is not always clear how to recover.</li>

      <li>It may or may not be appropriate to examine the object being finalized in order to determine what to do with it. In particular, it may be the Right Thing to protect the object from reclamation by placing it in a variable or a container, with or without re-registering it for finalization.</li></ul>

    <p>Guardians solve all of these problems at the expense of manual reclamation. Objects are preserved by a guardian; periodically, the guardian must be invoked to allow them to be reclaimed by the collector or to preserve them.</p>

    <h2 id="specification">Specification</h2>

    <p>This SRFI extends the reports on Scheme by stipulating that
      locations can be <dfn>strongly holding</dfn> and <dfn>weakly
        holding</dfn>.  Except as noted, all newly chosen locations are
      strongly holding.</p>

    <p>As specified in the reports on Scheme, implementations of
      Scheme are required to be properly tail-recursive.  The formal
      definition of proper tail-recursion can be found
      in <cite><a href="#clinger">[2]</a></cite>.  This SRFI extends
      the property tail recursive semantics in <cite>[2]</cite> by replacing the last line
      <blockquote>
        and <var>&beta;</var>, &hellip; do not occur within <var>v</var>, <var>&rho;</var>, <var>&kappa;</var>, <var>&sigma;</var>
      </blockquote>
      in the garbage collection rule with
      <blockquote>
        and <var>&beta;</var>, &hellip; do not occur within <var>v</var>, <var>&rho;</var>, <var>&kappa;</var>, <var>&sigma;'</var> where <var>&sigma;</var> = <var>&sigma;'</var>[<var>&beta;'</var>, &hellip; &mapsto; <var>v''</var>, &hellip;] and <var>&beta;'</var> are weakly holding.
      </blockquote>
    </p>

    <p>This SRFI further stipulates that locations and sequences of
      locations can be <dfn>kept live</dfn> in the course of a
      computation.
    </p>

    <p>Finally, it stipulates that objects may be <dfn>moved</dfn> in
      the course of a computation with the following restriction: If
      an object <var>obj<sub>1</sub></var> is moved, every
      object <var>obj<sub>2</sub></var> such that <code>eq?</code>
      returns <code>#t</code> when applied
      to <var>obj<sub>1</sub></var> and <var>obj<sub>2</sub></var> is moved as well.
    <p>

    <h3>Ephemerons</h3>

    <p>An <dfn>ephemeron</dfn> is a record structure with two fields
      called the <dfn>key</dfn> and <dfn>datum</dfn> fields whose
      contents are stored in weakly holding locations.</p>

    <p>Ephemerons can be <dfn>broken</dfn>.  If the content of its key
      field denotes a location or a sequence of locations, the
      ephemeron is broken in the course of the computation when the
      garbage collector reclaims the location or sequence of
      locations.  The ephemeron may be broken in the course of a
      computation if the Scheme implementation can prove that the
      location or sequence of locations will not be kept live in the
      future of the computation if the ephemeron is broken.
    </p>

    <p>Procedure: <strong>reference-barrier</strong> <var>obj</var></p>

    <p>If <var>obj</var> is an object such as a pair, string, vector,
      or bytevector that denotes a location or a sequence of
      locations, the location or the sequence of locations is kept
      live.
    </p>

    <p><i>Comment:</i> Other procedures may keep locations live as
      well.</p>

    <p>Procedure: <strong>make-ephemeron</strong> <var>key</var> <var>datum</var></p>

    <p>The <code>make-ephemeron</code> procedure returns a newly
      allocated ephemeron with fields <var>key</var>, which should
      denote a location or a sequence of locations,
      and <var>datum</var>.
    </p>

    <p>Procedure: <strong>ephemeron?</strong> <var>object</var></p>

    <p>The <code>ephemeron?</code> procedure returns <code>#t</code>
      if its argument is an ephemeron, and <code>#f</code> otherwise.
    </p>

    <p>Procedure: <strong>ephemeron-key</strong> <var>ephemeron</var></p>

    <p>The <code>ephemeron-key</code> procedure returns the contents
      of the key field of <var>ephemeron</var> if the ephemeron hasn't
      been broken, and <code>#f</code> otherwise.
    </p>

    <p>Procedure: <strong>ephemeron-datum</strong> <var>ephemeron</var></p>

    <p>The <code>ephemeron-datum</code> procedure returns the contents
      of the datum field of <var>ephemeron</var> if the ephemeron hasn't
      been broken, and <code>#f</code> otherwise.
    </p>

    <p>Procedure: <strong>ephemeron-broken?</strong> <var>ephemeron</var></p>

    <p>The <code>ephemeron-broken?</code> procedure
      returns <code>#t</code> if <var>ephemeron</var> has been broken,
      and <code>#f</code> otherwise.
    </p>

    <h3>Guardians</h3>

    <p>Guardians first appeared in <cite><a href="dybvig">[3]</a></cite>.</p>

    <p>A <dfn>guardian</dfn> is a heterogenous structure with two
      types of elements, <dfn>accessible</dfn> elements
      and <dfn>inaccessible</dfn> elements.  An accessible element is
      a record structure with two fields called the <dfn>object</dfn>
      and the <dfn>representative</dfn> field.  An inaccessible
      element contains a single value.
    </p>

    <p>An accessible element of a guardian can be <dfn>made
        inaccessible</dfn>.  When an accessible element is made
      inaccessible, the accessible element is removed from the
      guardian and an inaccessible element containing the content of
      the representative field of the removed accessible element is
      added to the guardian.
    </p>

    <p>If the content of an accessible element denotes a location or a
      sequence of locations, the element is made inaccessible in the
      course of the computation when the garbage collector would
      reclaim the location or sequence of locations if all locations
      denoted by the fields of accessible elements or by inaccessible
      elements of all guardians were weakly inaccessible.  The element
      may be made inaccessible in the course of a computation if the
      Scheme implementation can prove that the location or sequence of
      locations will not be kept live in the future of the computation
      if the element is made accessible.
    </p>

    <p>
      Guardians are represented by a Scheme
      procedures <var>guardian</var>.  When <var>guardian</var> is
      invoked on two Scheme values <var>obj</var> and <var>rep</var>,
      where <var>obj</var> should denote a location or a sequence of
      locations and <var>rep</var> should not be <code>#f</code>, an
      accessible element whose object field contains <var>obj</var>
      and whose representative field contains <var>rep</var> is added
      to the guardian.
    </p>

    <p>When <var>guardian</var> is invoked on no
      arguments, an inaccessible element if available is removed from
      the guardian and its contents returned.  If no inaccessible
      element is available, <code>#f</code> is returned.
    </p>

    <p>Procedure: <strong>make-guardian</strong></p>

    <p>The <code>make-guardian</code> procedure returns a newly
      allocated guardian, initially with no elements.
    </p>

    <p>Procedure: <strong>guardian?</strong> <var>obj</var></p>

    <p>The <code>guardian?</code> procedure returns <code>#t</code> if
      its argument is a guardian, and <code>#f</code> otherwise.
    </p>

    <h3>Transport Guardians</h3>

    <p>Transport (link) cells first appeared in <cite><a href="ghuloum">[1]</a></cite>.</p>

    <p>A <dfn>transport cell</dfn> is a record structure with two
      fields called the <dfn>key</dfn> and <dfn>datum</dfn> fields.
      The content of the key field is stored in a weakly holding
      location.
    </p>

    <p>Transport cells can be <dfn>broken</dfn>.  If the content of its key
      field denotes a location or a sequence of locations, the
      transport cell is broken in the course of the computation when the
      garbage collector reclaims the location or sequence of
      locations.  The transport cell may be broken in the course of a
      computation if the Scheme implementation can prove that the
      location or sequence of locations will not be kept live in the
      future of the computation if the ephemeron is broken.
    </p>

    <p>A <dfn>transport cell guardian</dfn> is a homogeneous structure
      contain transport cells.
    </p>

    <p>
      Transport cell guardians are represented by Scheme
      procedures <var>guardian</var>.  When <var>guardian</var> is
      invoked on two Scheme values <var>key</var>
      and <var>datum</var>, a transport cell with
      fields <var>key</var> and <var>datum</var> is added
      to <var>guardian</var> and returned to the caller
      of <var>guardian</var>.
    </p>

    <p>When <var>guardian</var> is invoked on no arguments and it
      contains a transport cell whose key may have been moved since
      the transport cell was added to <var>guardian</var>, such a
      transport cell is removed from <var>guardian</var> and returned
      to the caller of <var>guardian</var>.  If <var>guardian</var>
      contains no such transport cell, <code>#f</code> is returned.
    </p>

    <p>Procedure: <strong>current-hash</strong> <var>obj</var></p>

    <p>The <code>current-hash</code> procedure returns an exact
      integer. If objects <var>obj<sub>1</sub></var>
      and <var>obj<sub>2</sub></var> such that <code>eq?</code>
      returns <code>#t</code> when applied to these objects are not
      moved between an invocation of <code>current-hash</code>
      to <var>obj<sub>1</sub></var> and an invocation
      of <code>current-hash</code> to <var>obj<sub>2</sub></var>, both
      calls to <code>current-hash</code> return the same exact integer.
    </p>

    <p>Procedure: <strong>make-transport-cell-guardian</strong></p>

    <p>
      The <code>make-transport-cell-guardian</code> procedure returns
      a newly allocated transport cell guardian, initially containing
      no transport cells.
    </p>

    <p>Procedure: <strong>transport-cell-guardian?</strong> <var>obj</var></p>

    <p>The <code>transport-cell-guardian?</code> procedure returns <code>#t</code>
      if its argument is a transport cell guardian, and <code>#f</code> otherwise.
    </p>

    <p>Procedure: <strong>transport-cell?</strong> <var>obj</var></p>

    <p>The <code>transport-cell?</code> procedure returns <code>#t</code>
      if its argument is a transport cell, and <code>#f</code> otherwise.
    </p>

    <p>Procedure: <strong>transport-cell-key</strong> <var>transport-cell</var></p>

    <p>The <code>transport-cell-key</code> procedure returns the contents
      of the key field of <var>transport-cell</var> if the transport-cell hasn't
      been broken, and <code>#f</code> otherwise.
    </p>

    <p>Procedure: <strong>transport-cell-datum</strong> <var>transport-cell</var></p>

    <p>Procedure: <strong>transport-cell-broken?</strong> <var>transport-cell</var></p>

    <p>The <code>transport-cell-broken?</code> procedure
      returns <code>#t</code> if <var>transport-cell</var> has been broken,
      and <code>#f</code> otherwise.
    </p>

    <h2 id="implementation">Implementation</h2>

    <p>An implementation for Chez Scheme is provided.</p>

    <h2 id="references">References</h2>

    <ol>
      <li id="ghuloum"><a href="https://www.schemeworkshop.org/2007/procPaper3.pdf">Abdulziz Ghuloum and R. Kent Dybvig: <i>Generation-Friendly Eq Hash Tables</i></a></li>
      <li id="clinger"><a href="https://dl.acm.org/doi/pdf/10.1145/277650.277719">William D. Clinger: <i>Proper tail recursion and space efficiency</i></a></li>
      <li id="dybvig"><a href="https://dl.acm.org/doi/pdf/10.1145/173262.155110">R. Kent Dybvig, Carl Bruggeman, and David Eby: <i>Guardians in a Generation-Based Garbage Collector</i></a></li>
    </ol>

    <h2 id="acknowledgements">Acknowledgements</h2>

    <p>Thanks to the members of the SRFI discussion group, to John
      Cowan for writing SRFI 246, and to Kent Dybvig and his
      collaborators for creating Chez Scheme, its documentation, and
      the papers on guardians.
    </p>

    <h2 id="copyright">Copyright</h2>
    <p>&copy; 2024 Marc Nieper-Wißkirchen.</p>

    <p>
      Permission is hereby granted, free of charge, to any person
      obtaining a copy of this software and associated documentation files
      (the "Software"), to deal in the Software without restriction,
      including without limitation the rights to use, copy, modify, merge,
      publish, distribute, sublicense, and/or sell copies of the Software,
      and to permit persons to whom the Software is furnished to do so,
      subject to the following conditions:</p>

    <p>
      The above copyright notice and this permission notice (including the
      next paragraph) shall be included in all copies or substantial
      portions of the Software.</p>
    <p>
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
      NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
      BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
      ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
      CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
      SOFTWARE.</p>

    <hr>
    <address>Editor: <a href="mailto:srfi-editors+at+srfi+dot+schemers+dot+org">Arthur A. Gleckler</a></address>
  </body>
</html>
